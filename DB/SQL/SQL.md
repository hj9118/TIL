# 기본편

- 단어 사이에는 스페이스 혹은 줄 바꿈처리.
- 마지막에 `;` 세미콜론을 붙여야 한다.
- 별칭(AS)과 컬럼명이 같지 않도록 유의

<details> 
<summary><b>예약어 모음</b></summary>

## 기본

|  예약어  | 의미                                              |
| :------: | ------------------------------------------------- |
|  SELECT  | 무엇을 가져올지 선언하기 위해 사용                |
|   FROM   | 어디에서 가져올지 선언하기 위해 사용              |
|  WHERE   | SELECT문 내 조건에 해당하는 값을 불러올 때 사용   |
|    \*    | 전체 컬럼을 가져오기 위해 사용                    |
|    AS    | 컬럼에 별명을 붙여 직관적이고 짧게 불러올 수 있음 |
|   NULL   | NULL 값을 사용하기 위해 붙일 수 있다.             |
| DISTINCT | 중복 값 제거, 1개 통합한다. (SELECT 구에서 사용)  |

[일반 연산자](https://github.com/hj9118/TIL/blob/main/DB/SQL/SQL.md#where)

## WHERE문 용

|예약어 의미||
|IS|BOOLEAN과 NULL 용 연산자로 맞는지 파악|
|IS NOT|BOOLEAN과 NULL용 연산자로 아닌지 파악|
|BINARY|완전일치 검사로 공백과 대소문자도 포함하여 파악|
|LIKE|일부를 검색하기 위해 사용|
|NOT LIKE|일부를 검색하며 해당하지 않는 값을 찾는다.|
|%|앞/뒤에 붙으며 앞/뒤로 0개 이상의 문자가 있음을 의미|
|*|앞/뒤에 붙으며 공백포함 *의 개수만큼 문자가 있음을 의미|

</details>

[논리 연산자](https://github.com/hj9118/TIL/blob/main/DB/SQL/SQL.md#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%B6%99%EC%9D%BC-%EB%95%8C) </br>
[그외 연산자](https://github.com/hj9118/TIL/blob/main/DB/SQL/SQL.md#%EC%9D%B4%EC%99%B8%EC%9D%98-%EC%97%B0%EC%82%B0%EC%9E%90) </br>
[집약함수 모음]()

## SELECT

- `*` 을 지정할 경우 정렬순으로 출력
- 한 개의 컬럼을 여러개 지정할 수 있으며, \*과 컬럼명을 함께 사용할 수 있음
- 컬럼의 순서를 기존과 바꾸어 사용할 수 있음.

### 전체 데이터 가져오기

A 테이블의 전체 데이터를 불러올 경우

```sql
SELECT * FROM A;
```

### 일부 데이터 가져오기

A 테이블의 A_1, A_2 중 A_1 정보만 가져올 경우

```sql
SELECT A_1 FROM A;
```

## WHERE

- 연산자를 통해 컬럼 값을 비교하여 조건에 맞는지 파악

<details>
<summary><b>연산자 알아보기</b></summary>

| 연산자 | 예시  | 의미                     |
| :----: | ----- | ------------------------ |
|   =    | A=B   | A와 B가 동일             |
|  <=>   | A<=>B | A와 B가 동일 (null 대응) |
|   !=   | A!=B  | A와 B는 다름             |
|   <>   | A<>B  | A와 B는 다름             |
|   <    | A<\B  | A는 B보다 작음           |
|   >    | A>B   | A는 B보다 큼             |
|   <=   | A<=B  | A는 B 이하               |
|   >=   | A>=B  | A는 B 이상               |

</details>
</br>

### NULL 값을 찾을 때

A 테이블 내 A_2열 값이 `NULL`인 데이터의 A_1 값을 출력

```sql
SELECT A_1 FROM A
WHERE A_2 IS NULL;
```

> NULL을 찾기 위해서는 `= NULL`이 아닌 `IS NULL`로 작성할 것

### NULL 값이 아닌 데이터를 찾을 떄

```sql
SELECT A_1 FROM A
WHERE A_2 IS NOT NULL
```

> NULL 값이 아닌 값을 찾기 위해서는 `!= NULL`이 아닌 `IS NOT NULL`로 작성할 것.

#### NULL과 비교연산자

NULL을 비교 대상으로 삼을 경우 NULL 자신을 포함하는 값은 모두 NULL처리 </br>
`=`, `!=`, `<>`, `<`, `>` 처럼 비교대상으로 포함할 경우 모두 적용된다.

### 일치하는 문자열 검색

A테이블 중 A_1의 값이 'abc'와 동일하다면 출력

```sql
SELECT * FROM A
WHERE A_1 = 'abc';
```

> 문자열 검색시 대소문자를 구분하지 않으며, 끝의 공백은 무시한다.
> 이 경우 `AbC   `, `ABC `, `ABc` 등등 대소문자와 관계 없이 파악한다.

### 완전 일치 검색

A 테이블 A_1 값이 'abc'와 완전 동일하여야 출력 (대소문자 구분, 뒤 공백 미포함)

```sql
SELECT * FROM A
WHERE A_1 = BINARY 'abc';
```

### 일부 검색

ab가 포함된 값을 찾는다. abc, AB, AbC 등 검색 가능. 대소문자 구분시 `BINARY` 를 사용하며 포함하지 않는 값은 `NOT LIKE` 를 사용한다.

```sql
SELECT * FROM A
WHERE A_1 LIKE 'ab';
```

#### 일부 검색 더보기

`%`를 통해 문자 앞 혹은 뒤에 문자가 0개 이상 포함 되어있음을 의미한다.

- `%고기` ➡ 닭고기, 돼지고기 등 앞에 문자가 있을 수 있는 값 을 찾을 수 있음
- `김치%` ➡ 김치볶음밥, 김치찌개 등 뒤에 문자가 있을 수 있는 값을 찾을 수 있음
- `%우유%` ➡ 딸기우유, 우유푸딩, 흰우유1L 처럼 단어가 포함된 값을 찾을 수 있음
  </br>

`_`를 통해 문자 앞에 1문자가 있음을 의미한다.

- `_고기` ➡ 닭고기, 소고기 등을 의미 돼지고기는 포함하지 않음
- `김치__` ➡ 김치찌개 등을 의미. 김치찜, 김치볶음밥은 포함하지 않음 \* 공백도 한 문자로 처리하기 때문에 `흰 우유`는 `__우유`로 작성해야 한다.

### 문자 이스케이핑

`_`, `%` 를 문자로 사용하기 위해서는 이스케이핑을 통해 `\%` 처럼 작성해야한다.
100% 라는 단어를 포함한 값을 찾으려면?

```sql
(생략) WHERE col LIKE '%100\%%';
```

<details>
<summary><b>이스케이핑이 필요한 문자</b></summary>

| 이스케이핑 | 의미        |
| ---------- | ----------- |
| \%         | `%` 문자    |
| \_         | `_` 문자    |
| \\         | `\` 문자    |
| \'         | `'` 문자    |
| \"         | `"` 문자    |
| \n         | 줄 바꿈     |
| \t         | 탭 처리     |
| \b         | 백스페이스  |
| \r         | 줄바꿈 복구 |

</details>

### 숫자를 비교하여 값 한정하기

2000년 1월 1일 이전의 레코드를 찾을 때

```sql
SELECT * FROM A;
WHERE A_day < '2000-01-01';
```

> 날짜나 문자열에서 `=` 뿐만 아닌 `<`, `<=`, `=>`, `>`를 사용하여 대소 비교가 가능하다.

'A' 이후의 값을 찾을 때

```sql
SELECT * FROM A;
WHERE alpha > 'A';
```

> 문자열은 기본적으로 사전순으로 비교한다. 숫자를 문자형으로 작성시에는 숫자 값으로 정렬되지 않으니 참고

### 여러개의 조건을 붙일 때

논리 연산자를 통해 사용한다.

<details>
<summary><b>논리 연산자</b></summary>

| 명칭          | 연산자        | 예시                  | 의미                                                        |
| ------------- | ------------- | --------------------- | ----------------------------------------------------------- |
| 논리 곱       | `AND` / `&&`  | a `AND` b / a `&&` b  | a와 b 모두 true 여야 true                                   |
| 논리 합       | `OR` / `\|\|` | a `OR` b / a `\|\|` b | a 혹은 b 하나라도 true 라면 true                            |
| 부정          | `NOT` / `!`   | `NOT` a / `!`a        | a가 0일 경우 1. 0 이외는 0으로 값이 맞다면 아닌 것으로 처리 |
| 배타적 논리합 | `XOR`         | a `XOR` b             | a,b 중 하나만 true라면 true 아니라면 모두 false             |

</details>

#### AND 예시

값이 100이상 ~ 150미만인 값 찾기

```sql
SELECT * FROM A
WHERE price >= 100 AND price < 150;
```

#### OR 예시

색상이 빨간색이거나 파란색인 값 찾기

```sql
SELECT * FROM A
WHERE color = 'red' OR color = 'blue';
```

#### NOT 예시

id 값이 1이 아닌 값 찾기

```sql
SELECT * FROM A
WHERE NOT (id = 1);
```

> NOT 이후 우선순위로 인해 값이 달라질 수 있어 괄호로 묶어주는 것이 좋다.

#### XOR 예시

가격이 100 이상 150 미만 중 하나만 만족하는 값 찾기

```sql
SELECT * FROM A
WHERE price >= 100 XOR price < 150;
```

이 경우 100이하 혹은 150 이상인 값을 출력한다.

### 이외의 연산자

| 연산자            | 의미                | 예시                                    |
| ----------------- | ------------------- | --------------------------------------- |
| BETWEEN - AND     | BETWEEN a AND b     | a에서 b사이에 있을 경우 포함            |
| NOT BETWEEN - AND | NOT BETWEEN a AND b | a에서 b사이에 포함되지 않을 경우를 포함 |
| IN                | IN (a, b, c)        | a, b, c 중 일치하는 값이 있다면 반환    |
| NOT IN            | NOT IN (a, b, c)    | a, b, c 어느것도 포함되지 않는다면 반환 |

#### BETWEEN 시시

가격이 100이상 150 이하인 값 찾기

```sql
SELECT * FROM A
WHERE price BETWEEN 100 AND 150;
```

price >= 100 AND price <= 150 과 동일

#### NOT BETWEE시 예시

2000년 3월에서 2000년 5월 사이 값이 아닌 경우 찾기

```sql
SELECT * FROM A
WHERE A_date NOT BETWEEN '2000-03-01' AND '2000-05-31';
```

#### IN 예시

색상이 빨간색, 노란색, 초록색 중 있는 값 찾기

```sql
FROM * FROM A
WHERE color IN ('red', 'yellow', 'green');
```

color = 'red' OR color = 'yellow' OR color = 'green' 과 동일.</br>
여러개의 조건이 있다면 IN을 사용하는 것이 더 짧게 작성할 수 있다.

> OR, IN 모두 비교하는 개수가 많아지면 속도가 느려진다.

#### NOT IN 예시

id가 1,2,4가 아닌 값 찾기

```sql
FROM * FROM A
WHERE id NOT IS (1, 2, 4);
```

> 문자열을 IN, NOT IN을 사용하여 탐색시 빈 문자열인 `''`도 가능하나 `NULL`은 지정할 수 없음

### 연산자의 우선순서

컬럼을 연산할 수도 있음

개수와 가격을 통해 매출을 계산하여 5000 이상인 값 찾기

```sql
SELECT stock, price, stock * price FROM A
WHERE stock * price >= 5000;
```

SELECT 구역 내에서도 사용 가능하며, 소수, 음수도 사용 가능. </br>
`DIV`, `MOD` 와 같이 함수를 이용할 수도 있다. </br> \* NULL을 계산하면 모든 값은 NULL로 변하며 0으로 나눌 경우에도 NULL처리 된다.

> ### 연산자 우선 순위
>
> | 우선 순위                                 |
> | ----------------------------------------- |
> | BINARY                                    |
> | !                                         |
> | \*, /, DIV, %, MOD                        |
> | -, +                                      |
> | =, <=>, >=, <=, <,>, <>, !=, IS, LIKE, IN |
> | BETWEEN, CASE, WHEN, THEN, ELSE           |
> | NOT                                       |
> | &&, AND                                   |
> | XOR                                       |
> | \|\|, OR                                  |

### 순서에 따른 연산값

1. 괄호 없이 처리

```sql
SELECT * FROM A
WHERE price < 130 OR price > 150 AND stock >= 20;
```

stock이 20이상이면서 price가 150 초과인 값 중 price가 130보다 작거나 150보다 큰 수 </br>
150보다 크면서 130보다 작을 수 없어 결국 첫 연산 값과 동일함.

2. 괄호 포함 처리

```sql
SELECT * FROM A
WHERE (price < 130 OR price > 150) AND stock >= 20;
```

값이 130보다 작거나 150보다 큰 수 중 stock이 20이상인 값
이전과 달리 값이 130보다 작아도 개수가 20 이상이면 포함될 수 있음.

> 연산자 우선 규칙

1. `()`괄호가 최우선
2. 괄호가 없다면 우선 순위대로 처리
3. 같은 순위의 경우 순서대로 처리

### 중복 제거

`DISTINCT`를 이용해 테이블 내 중복을 제거한다.
여러개의 내역이 있을 경우 통합하여 같은 값만 제거
|name|price|
|-|-|
|과일|150|
|과일|100|
|과자|120|
|과자|120|
과자 120원은 동일

```sql
SELECT DISTINCT name, price FROM A
```

| name | price |
| ---- | ----- |
| 과일 | 150   |
| 과일 | 100   |
| 과자 | 120   |

### 함수식과 집약함수

```
함수명(인수) ➡ 결과값은 반환 값이라 부름
```

#### 집약 함수

| 함수명 | 인수           | 반환값                                                        |
| ------ | -------------- | ------------------------------------------------------------- |
| COUNT  | \* 혹은 컬럼명 | 레코드나 컬럼의 수                                            |
| SUM    | 컬럼명         | 컬럼의 합계 값                                                |
| MAX    | 컬럼명         | 컬럼의 최대값. </br>문자열은 사전순 최대 값, 날짜는 최신 값   |
| MIN    | 컬럼명         | 컬럼의 최소값. </br>문자열은 사전순 최소 값, 날짜는 오래된 값 |
| AVG    | 컬럼명         | 컬럼의 평균 값                                                |

**특징**

1. 집약함수는 SELECT, HAVING, ORDER BY 3곳에서 사용 가능하다.
2. 1개의 함수에서는 1개 값을 반환하며 함수와 컬럼 값을 동시에 출력하지 못한다.
3. 집약 함수와 함께 적을 수 있는 것은 상수, 집약 함수, DISTINCT, 연산자가 있다.
4. 컬럼 내 NULL이 있다면 NULL값을 무시하고 집계한다. (단, COUNT(\*) 제외)

## GROUP BY

GROUP BY를 통해 레코드를 그룹마다 통합하여 사용할 수 있다.

| name | price |
| ---- | ----- |
| 과일 | 150   |
| 과일 | 100   |
| 과자 | 120   |
| 과자 | 120   |

```sql
SELECT name, SUM(price) FROM A
GROUP BY name;
```

| name | price |
| ---- | ----- |
| 과일 | 250   |
| 과자 | 240   |

- GROUP BY 이후 나온 값을 기준으로 그룹화 진행 (집약 키)
- NULL도 하나의 그룹으로 처리된다. ➡ NULL은 삭제하고 진행할 것
- 그룹화 시행시 SELECT 구에는 상수, 집약 함수, 집약 키의 컬럼명 3가지만 지정할 수 있다.

### 집약키 여러개 사용하기

```sql
SELECT name, price, count(*) FROM A
GROUP BY name, price;
```

| name | price | count(\*) |
| ---- | ----- | :-------: |
| 과일 | 100   |     1     |
| 과일 | 150   |     1     |
| 과자 | 120   |     2     |

- 지정한 집약키 중 먼저 적은 키부터 그룹화를 진행

WHERE절과 GROUP BY절이 함께 있을 경우, </br>
WHERE절로 레코드를 줄인 뒤 GROUP BY절로 그룹화를 진행한다.

## HAVING

그룹에 대한 조건을 지정할 때 사용 </br>
HAVING절은 GROUP BY 다음에 작성한다. </br>
</br>
그룹화 시행시 집약 함수는 그룹마다 실행된다.
HAVING절에서 그룹화 시행시 사용할 수 있는 것은
상수, 집약 함수, 집약키의 컬럼명이 있습니다.

### HAVING vs WHERE

| HAVING            | WHERE                   |
| ----------------- | ----------------------- |
| 그룹에 대한 조건  | 레코드 전체에 대한 조건 |
| WHERE 이후에 실행 | 먼저 실행               |

> 데이터의 개수가 많다면 WHERE에서 먼저 줄여주는 것이 속도면에서 좋다.
